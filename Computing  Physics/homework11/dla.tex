\documentclass[11pt,a4paper,titlepage,openany]{book}
\usepackage[space]{ctex}
\usepackage{mathrsfs,amssymb,amsfonts,amsmath,bm,ntheorem,graphicx}
\usepackage[paperwidth=185mm,paperheight=260mm,text={148mm,210mm},left=21mm,includehead,vmarginratio=1:1]{geometry}
\usepackage{fancyhdr,titlesec,enumerate}
\begin{document}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[EL,OR]{\thepage}
\fancyhead[OC]{\nouppercase{\heiti\rightmark}}
\fancyhead[EC]{\nouppercase{\heiti\leftmark}}
\fancypagestyle{plain}{\renewcommand{\headrulewidth}{0pt}\fancyhf{}}
\theoremstyle{plain}
\newcounter{Proposition}[section]
\newenvironment{Proposition}[1][]{{\par\normalfont\bfseries 命题~\stepcounter{Proposition}\arabic{Proposition}#1~~}\kaishu}{\par}
\newcounter{Corollary}[section]
\newenvironment{Corollary}[1][]{{\par\normalfont\bfseries 推论~\stepcounter{Corollary}\arabic{Corollary}#1~~}\kaishu}{\par}
\newcounter{Theorem}[section]
\newenvironment{Theorem}[1][]{{\par\normalfont\bfseries 定理~\stepcounter{Theorem}\arabic{Theorem}#1~~}\kaishu}{\par}
\newcounter{Lemma}[section]
\newenvironment{Lemma}[1][]{{\par\normalfont\bfseries 引理~\stepcounter{Lemma}\arabic{Lemma}#1~~}\kaishu}{\par}
\newcounter{Property}[section]
\newenvironment{Property}[1][]{{\par\normalfont\bfseries 性质~\stepcounter{Property}\arabic{Property}#1~~}\kaishu}{\par}
\newcounter{Assertion}[section]
\newenvironment{Assertion}[1][]{{\par\normalfont\bfseries 断语~\stepcounter{Assertion}\arabic{Assertion}#1~~}\kaishu}{\par}
\newenvironment{Proof}{{\par{\heiti 证明}~~}}{\hfill $\square$ \par\hfill\par}
\newcounter{Example}[section]
\newenvironment{Example}[1][]{{\par\normalfont\bfseries 例~\stepcounter{Example}\arabic{Example}#1~~}\songti}{\hfill\par\hfill\par}
\newcounter{Def}[section]
\newenvironment{Def}[1][]{{\par\normalfont\bfseries 定义~\stepcounter{Def}\arabic{Def}#1~~\songti}}{\par}
\newcounter{Note}[section]
\newenvironment{Note}[1][]{{\par\normalfont\bfseries 注~\stepcounter{Note}\arabic{Note}#1~~}\songti}{\par}
\title{{\zihao{0}\heiti Homework10}}
\author{杨圣宇}
\maketitle
\chapter{Method Analysis}
\section{Generating}
Naturally we first think using a number set to save every particles' position,but actually this derive a large computation. If you want to judge whether this is another particle beside the target particle, it has to compare all particles generated before, not a local neighbourhood.\par
So, as we did in QFT, we can set a "vacuum" in a plane, which the fixed particles can be concerned as a active state settled in the "vacuum". Therefore, we need to set the number-set represent whether the particle be active or not which the index of number-set is the position of the particle, note that in C/C++ the index of number-set can not be negative, so we have to make the process in a region of $x>0,y>0$.\par
After we create the number-set, we need to set all the value equal zero except the center. Then we begin to generate the particle randomly in a circle, because if we generate begin in a very big circle, the particle will spends to much time to get to the center, so we can generate the particles with expanding the radius of circle.\par
But there maybe exist some other troubles with the random walk, if a particle run to the boundary we chose, we can consider put it back into the generating circle, cause in general the generating circle ia much larger than the cluster region, and the cluster actually is a local effect, we have enough evidence to say that the result of cluster has no relation with what particles behave far away from the center cluster.\par
\section{Fractal}
When we talk about the fractal of the DLA, there is another thing that we can not ignore that is the scale invariance, it will restrict us generating particle, we can not profit the number of generating in a circle varies linearly as radius, it actually varies as $r^{\delta}$ where $\delta$ is the fractal dimension of the DLA, so we have to correct our generator with the result from the linear hypothesis, it's not a very difficult process.\par
I will use the scale transformation to compute the fractal dimension with a very easy technique, linearly fit the function as $ln(N)\sim ln(r)$, of course the gradient is the $\delta$. Or I will use the most fundamental method such as count in a picture, because I don't want to compute so much.
\chapter{Result}
We can see the DLA:\par
\includegraphics[scale=0.18]{1.pdf}\par
And the relation of $ln(N)\sim ln(r)$:\par
\includegraphics{2.pdf}\par
We get the relation as $y=2.53039+1.51378x$, so $\delta=1.5138$\par
Here is the result of fitting:\par
\includegraphics{3.pdf}\par
And the compute on the picture also give the $\delta=1.55$.\par
\chapter{Others}
\section{appendix}
1.pdf\par
2.pdf\par
3.pdf\par
DLA.nb\par
test.dat\par
CP11DLA.exe\par
dla.cpp\par
\section{reference}
http://blog.csdn.net/liyuanbhu/article/details/8522144\par
C++ primer,2003.11,Stanley B.Lippman;Josee Lajoie;Barbara E.Moo,Pearson Education Asia LTD.
\end{document} 